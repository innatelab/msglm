//functions {
    // requires array_utils.stan

    // reimplementation of R contr.poly::make.poly()
    matrix contr_poly(int n) {
        vector[n] scores;
        matrix[n, n] x;
        matrix[n, n] r;

        for (i in 1:n) scores[i] = i;
        scores -= mean(scores);

        for (i in 1:n) {
            for (j in 1:n) {
                x[i, j] = scores[i]^(j-1);
            }
        }
        r = qr_Q(x) * diag_matrix(diagonal(qr_R(x)));
        r ./= rep_matrix(sqrt(columns_dot_self(r)), n);
        return block(r, 1, 2, n, n-1);
    }

    // count nonzero elements in effXeff0 matrix
    // (block-diagonal matrix with block generated by contr_poly())
    int contr_poly_Nw(int ngroups, int[] obj2group) {
        int nobjs[ngroups] = group_sizes(obj2group, ngroups);
        int nw = 0;
        for (i in 1:ngroups) nw += nobjs[i] > 0 ? (nobjs[i]-1)*nobjs[i] : 0;
        return nw;
    }

    matrix contr_treatment(int n) {
        matrix[n, n-1] r;

        r = rep_matrix(0.0, n, n-1);
        for (i in 1:(n-1)) r[i+1, i] = 1;
        return r;
    }

    // (non-zeros in block-diagonal matrix with blocks generated by contr_treatment())
    int contr_treatment_Nw(int ngroups, int[] obj2group) {
        int nobjs[ngroups] = group_sizes(obj2group, ngroups);
        int nw = 0;
        for (i in 1:ngroups) nw += nobjs[i] > 0 ? nobjs[i]-1 : 0;
        return nw;
    }

    matrix block_contr_treatment(int nblocks, int[] blockixs) {
        int N = size(blockixs);
        int NactiveBlocks = ndistinct(blockixs, nblocks);
        int Ndf = N - NactiveBlocks;
        matrix[N, Ndf] res = rep_matrix(0.0, N, Ndf);

        if (Ndf > 0) {
            int blocks[NactiveBlocks] = distinct(blockixs, nblocks);
            int nobjs[nblocks] = group_sizes(blockixs, nblocks);
            int col_offset = 0;
            for (k in 1:NactiveBlocks) { // process each block
                int blkix = blocks[k];
                int blksize = nobjs[blkix];
                matrix[blksize, blksize - 1] blk = contr_treatment(blksize);
                // collect positions of block object in resulting matrix
                int obj_poses[blksize];
                int obj_offset = 0;
                for (i in 1:N) {
                    if (blockixs[i] == blkix) {
                        obj_offset += 1;
                        obj_poses[obj_offset] = i;
                    }
                }
                for (i in 1:rows(blk)) for (j in 1:cols(blk)) {
                    res[obj_poses[i], col_offset + j] = blk[i, j];
                }
                col_offset += cols(blk);
            }
        }
        return res;
    }

    matrix block_contr_poly(int nblocks, int[] blockixs, real replace0) {
        int N = size(blockixs);
        int NactiveBlocks = ndistinct(blockixs, nblocks);
        int Ndf = N - NactiveBlocks;
        matrix[N, Ndf] res = rep_matrix(0.0, N, Ndf);

        if (Ndf > 0) {
            int blocks[NactiveBlocks] = distinct(blockixs, nblocks);
            int nobjs[nblocks] = group_sizes(blockixs, nblocks);
            int col_offset = 0;
            for (k in 1:NactiveBlocks) { // process each block
                int blkix = blocks[k];
                int blksize = nobjs[blkix];
                matrix[blksize, blksize - 1] blk = contr_poly(blksize);
                // collect positions of block object in resulting matrix
                int obj_poses[blksize];
                int obj_offset = 0;
                for (i in 1:N) {
                    if (blockixs[i] == blkix) {
                        obj_offset += 1;
                        obj_poses[obj_offset] = i;
                    }
                }
                for (i in 1:rows(blk)) for (j in 1:cols(blk)) {
                    // HACK: replace nonstructural zero with Inf,
                    //       so that these zeros are treated as non-zeros
                    //       and the total number of non-zeros fits contr_poly_Nw()
                    //       see csr_extract_w_0()
                    res[obj_poses[i], col_offset + j] = blk[i, j] == 0 ? replace0 : blk[i, j];
                }
                col_offset += cols(blk);
            }
        }
        return res;
    }

    // version of csr_extract_w() that replaces "replace0" values in the result with 0
    vector csr_extract_w_0(matrix m, real replace0) {
        vector[size(csr_extract_w(m))] res = csr_extract_w(m);
        for (i in 1:size(res)) {
            if (res[i] == replace0) {
                res[i] = 0.0;
            }
        }
        return res;
    }
//}
