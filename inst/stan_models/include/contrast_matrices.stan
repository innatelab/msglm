//functions {
    // requires array_utils.stan

    // reimplementation of R contr.poly::make.poly()
    matrix contr_poly(int n) {
        vector[n] scores;
        matrix[n, n] x;
        matrix[n, n] r;

        for (i in 1:n) scores[i] = i;
        scores -= mean(scores);

        for (i in 1:n) {
            for (j in 1:n) {
                x[i, j] = scores[i]^(j-1);
            }
        }
        r = qr_Q(x) * diag_matrix(diagonal(qr_R(x)));
        r ./= rep_matrix(sqrt(columns_dot_self(r)), n);
        return block(r, 1, 2, n, n-1);
    }

    // count nonzero elements in effXeff0 matrix
    // (block-diagonal matrix with block generated by contr_poly())
    int contr_poly_Nw(int ngroups, int[] obj2group) {
        int nobjs[ngroups] = group_sizes(obj2group, ngroups);
        int nw = 0;
        for (i in 1:ngroups) nw += nobjs[i] > 0 ? (nobjs[i]-1)*nobjs[i] : 0;
        return nw;
    }

    matrix contr_treatment(int n) {
        matrix[n, n-1] r;

        r = rep_matrix(0.0, n, n-1);
        for (i in 1:(n-1)) r[i+1, i] = 1;
        return r;
    }

    // (non-zeros in block-diagonal matrix with blocks generated by contr_treatment())
    int contr_treatment_Nw(int ngroups, int[] obj2group) {
        int nobjs[ngroups] = group_sizes(obj2group, ngroups);
        int nw = 0;
        for (i in 1:ngroups) nw += nobjs[i] > 0 ? nobjs[i]-1 : 0;
        return nw;
    }
//}
